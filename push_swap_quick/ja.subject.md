## 第二章: 序章
Push swap プロジェクトは、非常に単純で、非常にわかりやすいアルゴリズムプロジェクトです：データをソートする必要があります。
あなたは自由に、整数値のセット、2つのスタック、および両方のスタックを操作する命令のセットを持っています。
あなたの目標は？引数として受け取った整数をソートする、プッシュ・スワップ言語命令からなる最小のプログラムを計算し、標準出力に表示する push_swap という C 言語のプログラムを書くことである。
簡単？
そうですね...

## 第三章: 目的
ソートアルゴリズムを書くことは、開発者にとって常に非常に重要なステップである。それはしばしば、複雑さの概念との最初の出会いです。
ソートアルゴリズムとその複雑性は、就職の面接で議論される定番の質問の一部でもあります。いずれ直面することになるのだから、これらの概念に目を向けるのは良い機会だろう。
このプロジェクトの学習目標は、厳密さ、C言語の使用、基本的なアルゴリズムの使用です。
特にその複雑さに着目しています。
値の並べ替えは簡単です。最速でソートすることはそれほど単純ではありません。特に、整数の構成によって、最も効率的なソート方法は異なることがあるからだ。

## Chapter IV: Common Instructions
- あなたのプロジェクトはC言語で書かれている必要があります。
- あなたのプロジェクトは、Normに従って書かれていなければなりません。ボーナスファイルや関数がある場合、それらはノームチェックの対象となり、内部にノームエラーがある場合は0が返されます。
- 関数は未定義の動作とは別に、予期せぬ終了(セグメンテーションエラー、バスエラー、ダブルフリーなど)があってはなりません。もしこれが起こると、プロジェクトは非機能とみなされ、評価中に0が返されます。
- ヒープで確保されたメモリ空間は、必要なときに適切に解放されなければなりません。リークは許されません。
- 課題がそれを要求している場合、あなたはソースファイルを要求された出力にコンパイルする Makefile を提出しなければなりません。
- Makefile には少なくとも $(NAME), all, clean, fclean, re という規則が含まれていなければなりません。
- プロジェクトにボーナスを投入するには、Makefile にルール bonus を含める必要があります。これは、プロジェクトのメイン部分で禁止されている様々なヘッダ、 librairies、関数をすべて追加するものです。ボーナスは、主体が何も指定しない場合は、別のファイル _bonus.{c/h} にする必要があります。必須部分とボーナス部分の評価は別々に行われます。
- プロジェクトで libft を使用できるようにする場合、そのソースと関連する Makefile を libft フォルダにコピーしておく必要があります。あなたのプロジェクトのMakefileは、そのMakefileを使ってライブラリをコンパイルし、その後プロジェクトをコンパイルする必要があります。
- この作業は提出する必要はなく、採点もされませんが、あなたのプロジェクトのテストプログラムを作成することをお勧めします。テストプログラムを作成することで、自分の作品や仲間の作品を簡単にテストすることができます。このようなテストは、特にデフェンスの時に役立つと思います。実際、ディベートでは、あなたが作成したテストや、あなたが評価する仲間のテストを自由に使用することができます。
- あなたの作品を指定された git リポジトリに提出します。git リポジトリにある作品だけが採点されます。Deepthought があなたの作品を採点することになった場合、採点はあなたの相互評価後に行われます。
は、あなたの相互評価の後に行われます。Deepthoughtの採点中にあなたの作品のいずれかのセクションでエラーが発生した場合、評価は停止されます。

## Chapter V: Mandatory part
### V.1 ルール
- aとbという名前の2つのスタックを持っています。
- はじめに
  - スタック a には複製不可能な負の数および/または正の数がランダムに含まれている．
  - スタック b は空である．
- 目標は、スタック a に数字を昇順に並べ替えることである。
そのためには、以下の操作を自由に行うことができる。
sa (swap a): スタック a の先頭の 2 個の要素を交換する。
要素が 1 つしかない場合、または要素がない場合は何もしない。
sb (swap b): スタック b の先頭の 2 要素を交換する。
要素が1つしかない場合、または要素がない場合は何もしない。
ss : sa と sb を同時に実行。
pa (push a): bの先頭の要素をaの先頭に置く。
bが空の場合は何もしない。
pb (push b): aの先頭の要素を取り出し、bの先頭に置く。
aが空の場合は何もしない。
ra (rotate a): スタック a のすべての要素を 1 ずつ上にシフトする。
最初の要素が最後の要素になる。
rb (rotate b): スタック b の全要素を 1 ずつ上に移動させる．
最初の要素が最後の要素になる。
rr : ra と rb を同時に実行。
rra (reverse rotate a): スタック a の全要素を 1 つ下にシフトする。
最後の要素が最初の要素になる。
rrb (reverse rotate b): スタック b のすべての要素を 1 つ下にシフトします。
最後の要素が最初の要素になる．
rrr : rra と rrb を同時に実行。

### V.2 例題
これらの命令の効果を説明するために，整数のランダムなリストをソートしてみましょう．
この例では，両方のスタックが右から成長していくと考えることにする．
```
----------------------------------------------------------------------------------------------------------
Init a and b:
2
1
3
6
5
8
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec sa:
1
2
3
6
5
8
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec pb pb pb:
6 3
5 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec ra rb (equiv. to rr):
5 2
8 1
6 3
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec rra rrb (equiv. to rrr):
6 3
5 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec sa:
5 3
6 2
8 1
_ _
a b
----------------------------------------------------------------------------------------------------------
Exec pa pa pa:
1
2
3
5
6
8
_ _
a b
----------------------------------------------------------------------------------------------------------
```

aからの整数が12命令でソートされる。あなたはもっとうまくできますか？

### V.3 The "push_swap" program
|                  |                                                                            |
| ---------------- | -------------------------------------------------------------------------- |
| Program name     | push_swap                                                                  |
| Turn in files    | Makefile, *.h, *.c                                                         |
| Makefile         | NAME, all, clean, fclean, re                                               |
| Arguments        | stack a: A list of integers                                                |
| External functs. | • read, write, malloc, free, exit • ft_printf and any equivalent YOU coded |
| Libft authorized | Yes                                                                        |
| Description      | Sort stacks                                                                |

あなたのプロジェクトは、以下のルールに従わなければなりません。
- ソースファイルをコンパイルする Makefile を提出しなければなりません。再リンクはしてはいけません。
- グローバル変数は禁止されています。
- あなたは、引数として整数のリストとしてフォーマットされたスタックを受け取る、 push_swap という名前のプログラムを書かなければならない。最初の引数はスタックの一番上にあるべきである (順番に注意)。
- プログラムはスタック a を並べ替えるために可能な限り小さな命令のリストを表示しなければならず、最も小さい数が一番上になる。
- 命令は「\n」で区切られ、それ以外には何もないこと。
- 目標は、可能な限り少ない操作回数でスタックをソートすることである。評価プロセスでは、プログラムが見つけた命令の数が、許容される最大操作回数という制限と比較されます。あなたのプログラムがより長いリストを表示するか、数字が正しくソートされていない場合、あなたの成績は0となります。
- パラメータが指定されていない場合、プログラムは何も表示せず、プロンプトを返さなければなりません。
- エラーの場合は、標準エラーに「Error」の後に「'\n'」と表示しなければなりません。エラーとは、例えば、引数が整数でない、引数が整数より大きい、重複している、などです。

```log
$>./push_swap 2 1 3 6 5 8
sa
pb
pb
pb
sa
pa
pa
pa
$>./push_swap 0 one 2 3
Error
$>
```
評価プロセスでは、お客様のプログラムを適切にチェックするためのバイナリが提供されます。
これは次のように動作します。
```log
$>ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l
6
$>ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker_OS $ARG
OK
$>
```
プログラムチェッカー_OSが「KO」と表示した場合、あなたのpush_swapが数字をソートしていない命令リストを出してきたことを意味します。

## Chapter VI: Bonus part
This project leaves little room for adding extra features due to its simplicity. However,
how about creating your own checker?